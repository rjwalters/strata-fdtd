{"version":3,"file":"dataWorker-BYzrAhPz.js","sources":["../src/lib/performance.ts","../src/workers/dataWorker.ts"],"sourcesContent":["/**\n * Performance utilities for large grid optimization.\n *\n * Provides adaptive downsampling and performance metrics tracking.\n */\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface DownsampleOptions {\n  /** Target maximum voxels for real-time rendering (default: 262144 = 64³) */\n  targetVoxels: number;\n  /** Downsampling method */\n  method: \"nearest\" | \"average\" | \"max\";\n}\n\nexport interface DownsampleResult {\n  /** Downsampled pressure data */\n  data: Float32Array;\n  /** New grid shape after downsampling */\n  shape: [number, number, number];\n  /** Downsample factor applied (1 = no downsampling) */\n  factor: number;\n  /** Original shape */\n  originalShape: [number, number, number];\n}\n\nexport interface PerformanceMetrics {\n  /** Frames per second */\n  fps: number;\n  /** Frame time in milliseconds */\n  frameTime: number;\n  /** Number of voxels being rendered */\n  renderedVoxels: number;\n  /** Total voxels in data */\n  totalVoxels: number;\n  /** Downsampling factor (1 = none) */\n  downsampleFactor: number;\n  /** Estimated memory usage in MB */\n  memoryMB: number;\n}\n\n// =============================================================================\n// Default Configuration\n// =============================================================================\n\nexport const DEFAULT_DOWNSAMPLE_OPTIONS: DownsampleOptions = {\n  targetVoxels: 262144, // 64³ - good balance of quality and performance\n  method: \"average\",\n};\n\n// Performance thresholds\nexport const PERFORMANCE_THRESHOLDS = {\n  /** Target FPS for smooth playback */\n  targetFPS: 30,\n  /** Maximum voxels before forcing downsampling */\n  maxVoxelsForRealtime: 500000,\n  /** Warning threshold for rendered voxels */\n  warnVoxelCount: 200000,\n} as const;\n\n// =============================================================================\n// Downsampling\n// =============================================================================\n\n/**\n * Calculate optimal downsample factor based on grid size and target voxels.\n */\nexport function calculateDownsampleFactor(\n  shape: [number, number, number],\n  targetVoxels: number\n): number {\n  const totalVoxels = shape[0] * shape[1] * shape[2];\n  if (totalVoxels <= targetVoxels) {\n    return 1;\n  }\n  // Calculate factor to reduce to target voxels\n  // factor³ * target ≈ total, so factor = cbrt(total/target)\n  return Math.ceil(Math.pow(totalVoxels / targetVoxels, 1 / 3));\n}\n\n/**\n * Downsample 3D pressure data to reduce voxel count.\n *\n * Uses block-based sampling with configurable method (nearest, average, max).\n */\nexport function downsamplePressure(\n  data: Float32Array,\n  shape: [number, number, number],\n  options: Partial<DownsampleOptions> = {}\n): DownsampleResult {\n  const opts = { ...DEFAULT_DOWNSAMPLE_OPTIONS, ...options };\n  const [nx, ny, nz] = shape;\n  const totalVoxels = nx * ny * nz;\n\n  // Check if downsampling is needed\n  if (totalVoxels <= opts.targetVoxels) {\n    return {\n      data,\n      shape,\n      factor: 1,\n      originalShape: shape,\n    };\n  }\n\n  const factor = calculateDownsampleFactor(shape, opts.targetVoxels);\n\n  // Calculate new dimensions\n  const newNx = Math.ceil(nx / factor);\n  const newNy = Math.ceil(ny / factor);\n  const newNz = Math.ceil(nz / factor);\n  const newShape: [number, number, number] = [newNx, newNy, newNz];\n  const newTotal = newNx * newNy * newNz;\n\n  const result = new Float32Array(newTotal);\n\n  // Index helper for original data (row-major, z varies fastest)\n  const getIndex = (x: number, y: number, z: number): number =>\n    x * ny * nz + y * nz + z;\n\n  // Index helper for result data\n  const setIndex = (x: number, y: number, z: number): number =>\n    x * newNy * newNz + y * newNz + z;\n\n  // Downsample each block\n  for (let newX = 0; newX < newNx; newX++) {\n    for (let newY = 0; newY < newNy; newY++) {\n      for (let newZ = 0; newZ < newNz; newZ++) {\n        // Calculate block bounds in original data\n        const startX = newX * factor;\n        const startY = newY * factor;\n        const startZ = newZ * factor;\n        const endX = Math.min(startX + factor, nx);\n        const endY = Math.min(startY + factor, ny);\n        const endZ = Math.min(startZ + factor, nz);\n\n        let value: number;\n\n        switch (opts.method) {\n          case \"nearest\": {\n            // Use center of block\n            const centerX = Math.min(startX + Math.floor(factor / 2), nx - 1);\n            const centerY = Math.min(startY + Math.floor(factor / 2), ny - 1);\n            const centerZ = Math.min(startZ + Math.floor(factor / 2), nz - 1);\n            value = data[getIndex(centerX, centerY, centerZ)];\n            break;\n          }\n\n          case \"max\": {\n            // Use maximum absolute value (preserves peaks)\n            let maxAbs = 0;\n            let maxVal = 0;\n            for (let x = startX; x < endX; x++) {\n              for (let y = startY; y < endY; y++) {\n                for (let z = startZ; z < endZ; z++) {\n                  const v = data[getIndex(x, y, z)];\n                  const absV = Math.abs(v);\n                  if (absV > maxAbs) {\n                    maxAbs = absV;\n                    maxVal = v;\n                  }\n                }\n              }\n            }\n            value = maxVal;\n            break;\n          }\n\n          case \"average\":\n          default: {\n            // Average all values in block\n            let sum = 0;\n            let count = 0;\n            for (let x = startX; x < endX; x++) {\n              for (let y = startY; y < endY; y++) {\n                for (let z = startZ; z < endZ; z++) {\n                  sum += data[getIndex(x, y, z)];\n                  count++;\n                }\n              }\n            }\n            value = count > 0 ? sum / count : 0;\n            break;\n          }\n        }\n\n        result[setIndex(newX, newY, newZ)] = value;\n      }\n    }\n  }\n\n  return {\n    data: result,\n    shape: newShape,\n    factor,\n    originalShape: shape,\n  };\n}\n\n// =============================================================================\n// Threshold Filtering\n// =============================================================================\n\nexport interface FilterResult {\n  /** Indices of voxels above threshold */\n  indices: Uint32Array;\n  /** Pressure values at those indices */\n  values: Float32Array;\n  /** Count of voxels above threshold */\n  count: number;\n}\n\n/**\n * Filter pressure data to only include voxels above threshold.\n *\n * Returns indices and values for efficient sparse rendering.\n */\nexport function filterByThreshold(\n  data: Float32Array,\n  threshold: number,\n  maxPressure: number\n): FilterResult {\n  const thresholdValue = threshold * maxPressure;\n\n  // First pass: count matching voxels\n  let count = 0;\n  for (let i = 0; i < data.length; i++) {\n    if (Math.abs(data[i]) >= thresholdValue) {\n      count++;\n    }\n  }\n\n  // Allocate result arrays\n  const indices = new Uint32Array(count);\n  const values = new Float32Array(count);\n\n  // Second pass: collect indices and values\n  let idx = 0;\n  for (let i = 0; i < data.length; i++) {\n    if (Math.abs(data[i]) >= thresholdValue) {\n      indices[idx] = i;\n      values[idx] = data[i];\n      idx++;\n    }\n  }\n\n  return { indices, values, count };\n}\n\n// =============================================================================\n// Performance Tracking\n// =============================================================================\n\n/**\n * Performance tracker for measuring render performance.\n */\nexport class PerformanceTracker {\n  private frameTimes: number[] = [];\n  private maxSamples = 60;\n  private lastFrameTime = 0;\n  private _renderedVoxels = 0;\n  private _totalVoxels = 0;\n  private _downsampleFactor = 1;\n\n  /**\n   * Call at the start of each frame.\n   */\n  startFrame(): void {\n    this.lastFrameTime = performance.now();\n  }\n\n  /**\n   * Call at the end of each frame.\n   */\n  endFrame(): void {\n    const frameTime = performance.now() - this.lastFrameTime;\n    this.frameTimes.push(frameTime);\n    if (this.frameTimes.length > this.maxSamples) {\n      this.frameTimes.shift();\n    }\n  }\n\n  /**\n   * Update voxel counts for metrics.\n   */\n  updateVoxelCounts(\n    rendered: number,\n    total: number,\n    factor: number = 1\n  ): void {\n    this._renderedVoxels = rendered;\n    this._totalVoxels = total;\n    this._downsampleFactor = factor;\n  }\n\n  /**\n   * Get current performance metrics.\n   */\n  getMetrics(): PerformanceMetrics {\n    const avgFrameTime =\n      this.frameTimes.length > 0\n        ? this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length\n        : 0;\n\n    const fps = avgFrameTime > 0 ? 1000 / avgFrameTime : 0;\n\n    // Estimate memory: ~12 bytes per voxel (position + color + matrix ref)\n    const memoryMB = (this._renderedVoxels * 12) / (1024 * 1024);\n\n    return {\n      fps: Math.round(fps * 10) / 10,\n      frameTime: Math.round(avgFrameTime * 100) / 100,\n      renderedVoxels: this._renderedVoxels,\n      totalVoxels: this._totalVoxels,\n      downsampleFactor: this._downsampleFactor,\n      memoryMB: Math.round(memoryMB * 100) / 100,\n    };\n  }\n\n  /**\n   * Reset all metrics.\n   */\n  reset(): void {\n    this.frameTimes = [];\n    this._renderedVoxels = 0;\n    this._totalVoxels = 0;\n    this._downsampleFactor = 1;\n  }\n}\n\n// =============================================================================\n// Auto Quality Adjustment\n// =============================================================================\n\nexport interface QualitySettings {\n  /** Target voxels for downsampling */\n  targetVoxels: number;\n  /** Minimum threshold to apply */\n  minThreshold: number;\n  /** Voxel geometry type */\n  geometry: \"cube\" | \"sphere\" | \"point\";\n}\n\n/**\n * Suggest quality settings based on grid size and performance.\n */\nexport function suggestQualitySettings(\n  shape: [number, number, number],\n  currentFPS: number\n): QualitySettings {\n  const totalVoxels = shape[0] * shape[1] * shape[2];\n\n  // Default settings\n  const settings: QualitySettings = {\n    targetVoxels: 262144, // 64³\n    minThreshold: 0,\n    geometry: \"cube\",\n  };\n\n  // Adjust based on grid size\n  if (totalVoxels > 3000000) {\n    // > 150³: aggressive downsampling\n    settings.targetVoxels = 125000; // ~50³\n    settings.minThreshold = 0.05;\n    settings.geometry = \"point\";\n  } else if (totalVoxels > 1000000) {\n    // > 100³: moderate downsampling\n    settings.targetVoxels = 216000; // ~60³\n    settings.minThreshold = 0.02;\n    settings.geometry = \"point\";\n  } else if (totalVoxels > 500000) {\n    // > 80³: light downsampling\n    settings.targetVoxels = 262144; // 64³\n    settings.minThreshold = 0.01;\n    settings.geometry = \"cube\";\n  }\n\n  // Further adjust if FPS is too low\n  if (currentFPS > 0 && currentFPS < 20) {\n    settings.targetVoxels = Math.floor(settings.targetVoxels * 0.7);\n    settings.minThreshold = Math.max(settings.minThreshold, 0.03);\n  }\n\n  return settings;\n}\n","/**\n * Web Worker for heavy data processing operations.\n *\n * Handles downsampling and threshold filtering off the main thread\n * to prevent blocking the UI during playback.\n */\n\nimport {\n  downsamplePressure,\n  filterByThreshold,\n  type DownsampleOptions,\n  type DownsampleResult,\n  type FilterResult,\n} from \"@/lib/performance\";\n\n// =============================================================================\n// Message Types\n// =============================================================================\n\nexport type WorkerRequest =\n  | {\n      type: \"downsample\";\n      id: number;\n      data: Float32Array;\n      shape: [number, number, number];\n      options: Partial<DownsampleOptions>;\n    }\n  | {\n      type: \"filter\";\n      id: number;\n      data: Float32Array;\n      threshold: number;\n      maxPressure: number;\n    }\n  | {\n      type: \"downsampleAndFilter\";\n      id: number;\n      data: Float32Array;\n      shape: [number, number, number];\n      downsampleOptions: Partial<DownsampleOptions>;\n      threshold: number;\n    };\n\nexport type WorkerResponse =\n  | {\n      type: \"downsample\";\n      id: number;\n      result: DownsampleResult;\n    }\n  | {\n      type: \"filter\";\n      id: number;\n      result: FilterResult;\n    }\n  | {\n      type: \"downsampleAndFilter\";\n      id: number;\n      downsampleResult: DownsampleResult;\n      filterResult: FilterResult;\n    }\n  | {\n      type: \"error\";\n      id: number;\n      error: string;\n    };\n\n// =============================================================================\n// Worker Logic\n// =============================================================================\n\nself.onmessage = (event: MessageEvent<WorkerRequest>) => {\n  const request = event.data;\n\n  try {\n    switch (request.type) {\n      case \"downsample\": {\n        const result = downsamplePressure(\n          request.data,\n          request.shape,\n          request.options\n        );\n        const response: WorkerResponse = {\n          type: \"downsample\",\n          id: request.id,\n          result,\n        };\n        self.postMessage(response, { transfer: [result.data.buffer] });\n        break;\n      }\n\n      case \"filter\": {\n        const result = filterByThreshold(\n          request.data,\n          request.threshold,\n          request.maxPressure\n        );\n        const response: WorkerResponse = {\n          type: \"filter\",\n          id: request.id,\n          result,\n        };\n        self.postMessage(response, {\n          transfer: [result.indices.buffer, result.values.buffer],\n        });\n        break;\n      }\n\n      case \"downsampleAndFilter\": {\n        // Combined operation for efficiency\n        const downsampleResult = downsamplePressure(\n          request.data,\n          request.shape,\n          request.downsampleOptions\n        );\n\n        // Calculate max pressure for threshold\n        let maxPressure = 0;\n        for (let i = 0; i < downsampleResult.data.length; i++) {\n          const abs = Math.abs(downsampleResult.data[i]);\n          if (abs > maxPressure) maxPressure = abs;\n        }\n\n        const filterResult = filterByThreshold(\n          downsampleResult.data,\n          request.threshold,\n          maxPressure\n        );\n\n        const response: WorkerResponse = {\n          type: \"downsampleAndFilter\",\n          id: request.id,\n          downsampleResult,\n          filterResult,\n        };\n\n        // Transfer ownership of buffers for zero-copy\n        self.postMessage(response, {\n          transfer: [\n            downsampleResult.data.buffer,\n            filterResult.indices.buffer,\n            filterResult.values.buffer,\n          ],\n        });\n        break;\n      }\n    }\n  } catch (error) {\n    const errorResponse: WorkerResponse = {\n      type: \"error\",\n      id: request.id,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n    self.postMessage(errorResponse);\n  }\n};\n"],"names":["DEFAULT_DOWNSAMPLE_OPTIONS","calculateDownsampleFactor","shape","targetVoxels","totalVoxels","downsamplePressure","data","options","opts","nx","ny","nz","factor","newNx","newNy","newNz","newShape","newTotal","result","getIndex","x","y","z","setIndex","newX","newY","newZ","startX","startY","startZ","endX","endY","endZ","value","centerX","centerY","centerZ","maxAbs","maxVal","v","absV","sum","count","filterByThreshold","threshold","maxPressure","thresholdValue","i","indices","values","idx","event","request","response","downsampleResult","abs","filterResult","error","errorResponse"],"mappings":"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"}