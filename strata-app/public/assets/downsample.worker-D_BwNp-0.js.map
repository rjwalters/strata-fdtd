{"version":3,"file":"downsample.worker-D_BwNp-0.js","sources":["../src/workers/downsample.worker.ts"],"sourcesContent":["/**\n * Web Worker for downsampling operations.\n *\n * Offloads LTTB and min/max downsampling to a background thread\n * to keep the main thread responsive during large dataset processing.\n */\n\n// =============================================================================\n// Message Types\n// =============================================================================\n\nexport interface LTTBDownsampleRequest {\n  type: \"lttb\";\n  id: number;\n  data: Float32Array;\n  targetPoints: number;\n  sampleRate: number;\n}\n\nexport interface MinMaxDownsampleRequest {\n  type: \"minmax\";\n  id: number;\n  data: Float32Array;\n  targetPoints: number;\n  sampleRate: number;\n}\n\nexport interface LogBinDownsampleRequest {\n  type: \"logbin\";\n  id: number;\n  frequencies: Float32Array;\n  magnitude: Float32Array;\n  targetBins: number;\n  minFreq: number;\n  maxFreq: number;\n}\n\nexport type DownsampleWorkerRequest =\n  | LTTBDownsampleRequest\n  | MinMaxDownsampleRequest\n  | LogBinDownsampleRequest;\n\nexport interface LTTBDownsampleResponse {\n  type: \"lttb\";\n  id: number;\n  // Interleaved [x0, y0, x1, y1, ...] for efficient transfer\n  points: Float32Array;\n  length: number;\n}\n\nexport interface MinMaxDownsampleResponse {\n  type: \"minmax\";\n  id: number;\n  points: Float32Array;\n  length: number;\n}\n\nexport interface LogBinDownsampleResponse {\n  type: \"logbin\";\n  id: number;\n  frequencies: Float32Array;\n  magnitude: Float32Array;\n}\n\nexport interface DownsampleWorkerError {\n  type: \"error\";\n  id: number;\n  error: string;\n}\n\nexport type DownsampleWorkerMessage =\n  | LTTBDownsampleResponse\n  | MinMaxDownsampleResponse\n  | LogBinDownsampleResponse\n  | DownsampleWorkerError;\n\n// =============================================================================\n// Downsampling Algorithms (duplicated to avoid module import issues in worker)\n// =============================================================================\n\n/**\n * LTTB downsampling - preserves visual fidelity\n */\nfunction lttbDownsampleWorker(\n  data: Float32Array,\n  targetPoints: number,\n  sampleRate: number\n): Float32Array {\n  const dataLength = data.length;\n\n  // Convert to time-value pairs\n  const msPerSample = 1000 / sampleRate;\n\n  // If we have fewer points than target, return all\n  if (targetPoints >= dataLength || targetPoints < 3) {\n    const result = new Float32Array(dataLength * 2);\n    for (let i = 0; i < dataLength; i++) {\n      result[i * 2] = i * msPerSample;\n      result[i * 2 + 1] = data[i];\n    }\n    return result;\n  }\n\n  const sampled: number[] = [];\n  const bucketSize = (dataLength - 2) / (targetPoints - 2);\n\n  // Always include first point\n  sampled.push(0 * msPerSample, data[0]);\n\n  let a = 0; // Previously selected point index\n\n  for (let i = 0; i < targetPoints - 2; i++) {\n    const bucketStart = Math.floor((i + 1) * bucketSize) + 1;\n    const bucketEnd = Math.floor((i + 2) * bucketSize) + 1;\n    const actualBucketEnd = Math.min(bucketEnd, dataLength - 1);\n\n    // Calculate average point in next bucket\n    const nextBucketStart = Math.floor((i + 2) * bucketSize) + 1;\n    const nextBucketEnd = Math.floor((i + 3) * bucketSize) + 1;\n    const actualNextBucketEnd = Math.min(nextBucketEnd, dataLength);\n\n    let avgX = 0;\n    let avgY = 0;\n    let nextBucketCount = 0;\n\n    for (let j = nextBucketStart; j < actualNextBucketEnd; j++) {\n      avgX += j * msPerSample;\n      avgY += data[j];\n      nextBucketCount++;\n    }\n\n    if (nextBucketCount > 0) {\n      avgX /= nextBucketCount;\n      avgY /= nextBucketCount;\n    } else {\n      avgX = (dataLength - 1) * msPerSample;\n      avgY = data[dataLength - 1];\n    }\n\n    // Point A\n    const pointAX = a * msPerSample;\n    const pointAY = data[a];\n\n    // Find point with largest triangle area\n    let maxArea = -1;\n    let maxAreaIndex = bucketStart;\n\n    for (let j = bucketStart; j < actualBucketEnd; j++) {\n      const pointBX = j * msPerSample;\n      const pointBY = data[j];\n\n      const area = Math.abs(\n        (pointAX - avgX) * (pointBY - pointAY) -\n          (pointAX - pointBX) * (avgY - pointAY)\n      );\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaIndex = j;\n      }\n    }\n\n    sampled.push(maxAreaIndex * msPerSample, data[maxAreaIndex]);\n    a = maxAreaIndex;\n  }\n\n  // Always include last point\n  sampled.push((dataLength - 1) * msPerSample, data[dataLength - 1]);\n\n  return new Float32Array(sampled);\n}\n\n/**\n * Min-max downsampling - preserves peaks\n */\nfunction minMaxDownsampleWorker(\n  data: Float32Array,\n  targetPoints: number,\n  sampleRate: number\n): Float32Array {\n  const dataLength = data.length;\n  const msPerSample = 1000 / sampleRate;\n\n  if (targetPoints >= dataLength || targetPoints < 2) {\n    const result = new Float32Array(dataLength * 2);\n    for (let i = 0; i < dataLength; i++) {\n      result[i * 2] = i * msPerSample;\n      result[i * 2 + 1] = data[i];\n    }\n    return result;\n  }\n\n  const bucketSize = dataLength / targetPoints;\n  const result: number[] = [];\n\n  for (let i = 0; i < targetPoints; i++) {\n    const bucketStart = Math.floor(i * bucketSize);\n    const bucketEnd = Math.min(Math.floor((i + 1) * bucketSize), dataLength);\n\n    let min = data[bucketStart];\n    let max = data[bucketStart];\n    let minIdx = bucketStart;\n    let maxIdx = bucketStart;\n\n    for (let j = bucketStart; j < bucketEnd; j++) {\n      if (data[j] < min) {\n        min = data[j];\n        minIdx = j;\n      }\n      if (data[j] > max) {\n        max = data[j];\n        maxIdx = j;\n      }\n    }\n\n    // Add points in temporal order\n    if (minIdx <= maxIdx) {\n      result.push(minIdx * msPerSample, min);\n      if (minIdx !== maxIdx) {\n        result.push(maxIdx * msPerSample, max);\n      }\n    } else {\n      result.push(maxIdx * msPerSample, max);\n      result.push(minIdx * msPerSample, min);\n    }\n  }\n\n  return new Float32Array(result);\n}\n\n/**\n * Log-bin downsampling for spectrum data\n */\nfunction logBinDownsampleWorker(\n  frequencies: Float32Array,\n  magnitude: Float32Array,\n  targetBins: number,\n  minFreq: number,\n  maxFreq: number\n): { frequencies: Float32Array; magnitude: Float32Array } {\n  const logMin = Math.log10(Math.max(minFreq, 1));\n  const logMax = Math.log10(maxFreq);\n  const logStep = (logMax - logMin) / targetBins;\n\n  const outFreq = new Float32Array(targetBins);\n  const outMag = new Float32Array(targetBins);\n\n  for (let i = 0; i < targetBins; i++) {\n    const binLowFreq = Math.pow(10, logMin + i * logStep);\n    const binHighFreq = Math.pow(10, logMin + (i + 1) * logStep);\n    const binCenterFreq = Math.sqrt(binLowFreq * binHighFreq);\n\n    let maxMag = 0;\n    let found = false;\n\n    for (let j = 0; j < frequencies.length; j++) {\n      if (frequencies[j] >= binLowFreq && frequencies[j] < binHighFreq) {\n        found = true;\n        if (magnitude[j] > maxMag) {\n          maxMag = magnitude[j];\n        }\n      }\n    }\n\n    outFreq[i] = binCenterFreq;\n    outMag[i] = found ? maxMag : 0;\n  }\n\n  return { frequencies: outFreq, magnitude: outMag };\n}\n\n// =============================================================================\n// Worker Message Handler\n// =============================================================================\n\nself.onmessage = (event: MessageEvent<DownsampleWorkerRequest>) => {\n  const request = event.data;\n\n  try {\n    switch (request.type) {\n      case \"lttb\": {\n        const points = lttbDownsampleWorker(\n          request.data,\n          request.targetPoints,\n          request.sampleRate\n        );\n\n        const response: LTTBDownsampleResponse = {\n          type: \"lttb\",\n          id: request.id,\n          points,\n          length: points.length / 2,\n        };\n\n        self.postMessage(response, { transfer: [points.buffer] });\n        break;\n      }\n\n      case \"minmax\": {\n        const points = minMaxDownsampleWorker(\n          request.data,\n          request.targetPoints,\n          request.sampleRate\n        );\n\n        const response: MinMaxDownsampleResponse = {\n          type: \"minmax\",\n          id: request.id,\n          points,\n          length: points.length / 2,\n        };\n\n        self.postMessage(response, { transfer: [points.buffer] });\n        break;\n      }\n\n      case \"logbin\": {\n        const result = logBinDownsampleWorker(\n          request.frequencies,\n          request.magnitude,\n          request.targetBins,\n          request.minFreq,\n          request.maxFreq\n        );\n\n        const response: LogBinDownsampleResponse = {\n          type: \"logbin\",\n          id: request.id,\n          frequencies: result.frequencies,\n          magnitude: result.magnitude,\n        };\n\n        self.postMessage(response, {\n          transfer: [result.frequencies.buffer, result.magnitude.buffer],\n        });\n        break;\n      }\n    }\n  } catch (error) {\n    const errorResponse: DownsampleWorkerError = {\n      type: \"error\",\n      id: request.id,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n    self.postMessage(errorResponse);\n  }\n};\n"],"names":["lttbDownsampleWorker","data","targetPoints","sampleRate","dataLength","msPerSample","result","i","sampled","bucketSize","a","bucketStart","bucketEnd","actualBucketEnd","nextBucketStart","nextBucketEnd","actualNextBucketEnd","avgX","avgY","nextBucketCount","j","pointAX","pointAY","maxArea","maxAreaIndex","pointBX","pointBY","area","minMaxDownsampleWorker","min","max","minIdx","maxIdx","logBinDownsampleWorker","frequencies","magnitude","targetBins","minFreq","maxFreq","logMin","logStep","outFreq","outMag","binLowFreq","binHighFreq","binCenterFreq","maxMag","found","event","request","points","response","error","errorResponse"],"mappings":"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"}