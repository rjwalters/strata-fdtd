{"version":3,"file":"fft.worker-DxnGi49G.js","sources":["../src/lib/fft.ts","../src/workers/fft.worker.ts"],"sourcesContent":["/**\n * Pure TypeScript FFT implementation using Cooley-Tukey radix-2 algorithm.\n * Zero dependencies, properly bundleable.\n */\n\n/**\n * Compute FFT of real-valued input data.\n * Returns complex output as interleaved [re0, im0, re1, im1, ...] array.\n */\nexport function realFFT(input: number[], n: number): Float32Array {\n  // Pad or truncate to size n\n  const padded = new Array(n).fill(0);\n  for (let i = 0; i < Math.min(input.length, n); i++) {\n    padded[i] = input[i];\n  }\n\n  // Bit-reversal permutation\n  const bits = Math.log2(n);\n  const re = new Float32Array(n);\n  const im = new Float32Array(n);\n\n  for (let i = 0; i < n; i++) {\n    const j = bitReverse(i, bits);\n    re[j] = padded[i];\n  }\n\n  // Cooley-Tukey FFT\n  for (let size = 2; size <= n; size *= 2) {\n    const halfSize = size / 2;\n    const angleStep = (-2 * Math.PI) / size;\n\n    for (let i = 0; i < n; i += size) {\n      for (let j = 0; j < halfSize; j++) {\n        const angle = angleStep * j;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const evenIdx = i + j;\n        const oddIdx = i + j + halfSize;\n\n        const tRe = cos * re[oddIdx] - sin * im[oddIdx];\n        const tIm = sin * re[oddIdx] + cos * im[oddIdx];\n\n        re[oddIdx] = re[evenIdx] - tRe;\n        im[oddIdx] = im[evenIdx] - tIm;\n        re[evenIdx] = re[evenIdx] + tRe;\n        im[evenIdx] = im[evenIdx] + tIm;\n      }\n    }\n  }\n\n  // Interleave real and imaginary parts\n  const out = new Float32Array(n * 2);\n  for (let i = 0; i < n; i++) {\n    out[2 * i] = re[i];\n    out[2 * i + 1] = im[i];\n  }\n\n  return out;\n}\n\n/**\n * Reverse bits of an integer.\n */\nfunction bitReverse(x: number, bits: number): number {\n  let result = 0;\n  for (let i = 0; i < bits; i++) {\n    result = (result << 1) | (x & 1);\n    x >>= 1;\n  }\n  return result;\n}\n\n/**\n * Compute power spectrum from real input data.\n * Applies Hanning window and returns only positive frequencies.\n */\nexport function computeSpectrum(\n  data: Float32Array,\n  sampleRate: number,\n  nfft?: number\n): { frequencies: Float32Array; magnitude: Float32Array } {\n  const n = nfft ?? nextPowerOf2(data.length);\n\n  // Apply Hanning window\n  const windowed: number[] = new Array(n).fill(0);\n  for (let i = 0; i < Math.min(data.length, n); i++) {\n    const window = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (data.length - 1)));\n    windowed[i] = data[i] * window;\n  }\n\n  // Compute FFT\n  const fftOut = realFFT(windowed, n);\n\n  // Compute magnitude (only positive frequencies up to Nyquist)\n  const nyquist = n / 2;\n  const frequencies = new Float32Array(nyquist);\n  const magnitude = new Float32Array(nyquist);\n\n  for (let i = 0; i < nyquist; i++) {\n    const re = fftOut[2 * i];\n    const im = fftOut[2 * i + 1];\n    frequencies[i] = (i * sampleRate) / n;\n    magnitude[i] = Math.sqrt(re * re + im * im) / n;\n  }\n\n  return { frequencies, magnitude };\n}\n\n/**\n * Find the next power of 2 >= n.\n */\nexport function nextPowerOf2(n: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n// =============================================================================\n// Web Worker Support\n// =============================================================================\n\nimport type {\n  FFTWorkerRequest,\n  FFTWorkerMessage,\n} from \"../workers/fft.worker\";\n\nlet fftWorker: Worker | null = null;\nlet requestId = 0;\nconst pendingRequests = new Map<\n  number,\n  {\n    resolve: (value: { frequencies: Float32Array; magnitude: Float32Array }) => void;\n    reject: (error: Error) => void;\n  }\n>();\n\n/**\n * Check if Web Workers are available in the current environment.\n */\nexport function hasWorkerSupport(): boolean {\n  return typeof Worker !== \"undefined\";\n}\n\n/**\n * Get or create the FFT worker instance.\n */\nfunction getFFTWorker(): Worker | null {\n  if (!hasWorkerSupport()) {\n    return null;\n  }\n\n  if (!fftWorker) {\n    try {\n      fftWorker = new Worker(\n        new URL(\"../workers/fft.worker.ts\", import.meta.url),\n        { type: \"module\" }\n      );\n\n      fftWorker.onmessage = (event: MessageEvent<FFTWorkerMessage>) => {\n        const message = event.data;\n        const pending = pendingRequests.get(message.id);\n\n        if (pending) {\n          pendingRequests.delete(message.id);\n\n          if (message.type === \"error\") {\n            pending.reject(new Error(message.error));\n          } else {\n            pending.resolve({\n              frequencies: message.frequencies,\n              magnitude: message.magnitude,\n            });\n          }\n        }\n      };\n\n      fftWorker.onerror = (error) => {\n        console.error(\"FFT Worker error:\", error);\n        // Reject all pending requests\n        for (const [id, pending] of pendingRequests) {\n          pending.reject(new Error(\"Worker error\"));\n          pendingRequests.delete(id);\n        }\n        // Reset worker so it can be recreated\n        fftWorker = null;\n      };\n    } catch {\n      console.warn(\"Failed to create FFT worker, falling back to main thread\");\n      return null;\n    }\n  }\n\n  return fftWorker;\n}\n\n/**\n * Compute spectrum asynchronously using a Web Worker.\n * Falls back to synchronous computation if workers are unavailable.\n *\n * @param data - Input audio samples\n * @param sampleRate - Sample rate in Hz\n * @param nfft - Optional FFT size (defaults to next power of 2)\n * @returns Promise resolving to { frequencies, magnitude }\n */\nexport async function computeSpectrumAsync(\n  data: Float32Array,\n  sampleRate: number,\n  nfft?: number\n): Promise<{ frequencies: Float32Array; magnitude: Float32Array }> {\n  const worker = getFFTWorker();\n\n  // Fallback to synchronous computation\n  if (!worker) {\n    return computeSpectrum(data, sampleRate, nfft);\n  }\n\n  const id = requestId++;\n\n  return new Promise((resolve, reject) => {\n    pendingRequests.set(id, { resolve, reject });\n\n    const request: FFTWorkerRequest = {\n      type: \"computeSpectrum\",\n      id,\n      data,\n      sampleRate,\n      nfft,\n    };\n\n    // Transfer the data buffer if possible (for large datasets)\n    // Note: This transfers ownership, so the caller shouldn't use data after this\n    if (data.length > 100000) {\n      // Make a copy since we're transferring\n      const dataCopy = new Float32Array(data);\n      worker.postMessage(\n        { ...request, data: dataCopy },\n        { transfer: [dataCopy.buffer] }\n      );\n    } else {\n      worker.postMessage(request);\n    }\n  });\n}\n\n/**\n * Terminate the FFT worker and clean up resources.\n * Call this when the worker is no longer needed.\n */\nexport function terminateFFTWorker(): void {\n  if (fftWorker) {\n    fftWorker.terminate();\n    fftWorker = null;\n    pendingRequests.clear();\n  }\n}\n","/**\n * Web Worker for FFT computation.\n *\n * Offloads computationally intensive spectrum analysis to a background thread\n * to keep the main thread responsive during large dataset processing.\n */\n\nimport { realFFT, nextPowerOf2 } from \"@/lib/fft\";\n\n// =============================================================================\n// Message Types\n// =============================================================================\n\nexport interface FFTWorkerRequest {\n  type: \"computeSpectrum\";\n  id: number;\n  data: Float32Array;\n  sampleRate: number;\n  nfft?: number;\n}\n\nexport interface FFTWorkerResponse {\n  type: \"computeSpectrum\";\n  id: number;\n  frequencies: Float32Array;\n  magnitude: Float32Array;\n}\n\nexport interface FFTWorkerError {\n  type: \"error\";\n  id: number;\n  error: string;\n}\n\nexport type FFTWorkerMessage = FFTWorkerResponse | FFTWorkerError;\n\n// =============================================================================\n// Worker Logic\n// =============================================================================\n\n/**\n * Compute power spectrum from real input data.\n * Applies Hanning window and returns only positive frequencies.\n */\nfunction computeSpectrumWorker(\n  data: Float32Array,\n  sampleRate: number,\n  nfft?: number\n): { frequencies: Float32Array; magnitude: Float32Array } {\n  const n = nfft ?? nextPowerOf2(data.length);\n\n  // Apply Hanning window\n  const windowed: number[] = new Array(n).fill(0);\n  for (let i = 0; i < Math.min(data.length, n); i++) {\n    const window = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (data.length - 1)));\n    windowed[i] = data[i] * window;\n  }\n\n  // Compute FFT\n  const fftOut = realFFT(windowed, n);\n\n  // Compute magnitude (only positive frequencies up to Nyquist)\n  const nyquist = n / 2;\n  const frequencies = new Float32Array(nyquist);\n  const magnitude = new Float32Array(nyquist);\n\n  for (let i = 0; i < nyquist; i++) {\n    const re = fftOut[2 * i];\n    const im = fftOut[2 * i + 1];\n    frequencies[i] = (i * sampleRate) / n;\n    magnitude[i] = Math.sqrt(re * re + im * im) / n;\n  }\n\n  return { frequencies, magnitude };\n}\n\nself.onmessage = (event: MessageEvent<FFTWorkerRequest>) => {\n  const request = event.data;\n\n  try {\n    switch (request.type) {\n      case \"computeSpectrum\": {\n        const result = computeSpectrumWorker(\n          request.data,\n          request.sampleRate,\n          request.nfft\n        );\n\n        const response: FFTWorkerResponse = {\n          type: \"computeSpectrum\",\n          id: request.id,\n          frequencies: result.frequencies,\n          magnitude: result.magnitude,\n        };\n\n        // Transfer ownership of buffers for zero-copy\n        self.postMessage(response, {\n          transfer: [result.frequencies.buffer, result.magnitude.buffer],\n        });\n        break;\n      }\n    }\n  } catch (error) {\n    const errorResponse: FFTWorkerError = {\n      type: \"error\",\n      id: request.id,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n    self.postMessage(errorResponse);\n  }\n};\n"],"names":["realFFT","input","n","padded","i","bits","re","im","j","bitReverse","size","halfSize","angleStep","angle","cos","sin","evenIdx","oddIdx","tRe","tIm","out","x","result","nextPowerOf2","computeSpectrumWorker","data","sampleRate","nfft","windowed","window","fftOut","nyquist","frequencies","magnitude","event","request","response","error","errorResponse"],"mappings":"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"}