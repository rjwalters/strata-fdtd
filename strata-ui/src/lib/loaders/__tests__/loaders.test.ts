/**
 * Unit tests for FDTD simulation data loaders.
 *
 * Tests use the sample data generated by generate_viz_sample_data.py
 * Tests are skipped if sample data is not present.
 */

import { describe, it, expect, beforeAll, vi } from 'vitest';
import { readFile, access } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

// Import loaders
import { loadManifest, loadMetadata } from '../manifest';
import { loadSnapshot } from '../snapshot';
import { loadGeometry } from '../geometry';
import { loadProbeData, getTimeArray, getFrequencyResponse } from '../probes';
import type { SimulationManifest, SimulationMetadata, SnapshotInfo, GeometryInfo } from '../types';

// Sample data path (ESM compatible)
const __dirname = dirname(fileURLToPath(import.meta.url));
const SAMPLE_DATA_PATH = join(__dirname, '../../../../public/sample-data');

// Check if sample data exists
let hasSampleData = false;
try {
  await access(join(SAMPLE_DATA_PATH, 'helmholtz_manifest.json'));
  hasSampleData = true;
} catch {
  hasSampleData = false;
}

// Mock fetch for node environment
let mockManifest: SimulationManifest;
let mockMetadata: SimulationMetadata;
let mockProbeData: Record<string, unknown>;

beforeAll(async () => {
  if (!hasSampleData) return;

  // Load sample data files directly for mocking
  const manifestJson = await readFile(join(SAMPLE_DATA_PATH, 'helmholtz_manifest.json'), 'utf-8');
  mockManifest = JSON.parse(manifestJson);

  const metadataJson = await readFile(join(SAMPLE_DATA_PATH, 'helmholtz_metadata.json'), 'utf-8');
  mockMetadata = JSON.parse(metadataJson);

  const probeJson = await readFile(join(SAMPLE_DATA_PATH, 'helmholtz_probes.json'), 'utf-8');
  mockProbeData = JSON.parse(probeJson);

  // Mock fetch
  vi.stubGlobal('fetch', vi.fn(async (url: string) => {
    if (url.includes('manifest')) {
      return {
        ok: true,
        json: async () => mockManifest,
      };
    }
    if (url.includes('metadata')) {
      return {
        ok: true,
        json: async () => mockMetadata,
      };
    }
    if (url.includes('probes')) {
      return {
        ok: true,
        json: async () => mockProbeData,
      };
    }
    if (url.includes('geometry')) {
      const buffer = await readFile(join(SAMPLE_DATA_PATH, 'helmholtz_geometry.bin'));
      return {
        ok: true,
        headers: { get: () => buffer.length.toString() },
        arrayBuffer: async () => buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength),
      };
    }
    if (url.includes('snapshot_0000')) {
      const buffer = await readFile(join(SAMPLE_DATA_PATH, 'helmholtz_snapshot_0000.bin'));
      return {
        ok: true,
        headers: { get: () => buffer.length.toString() },
        arrayBuffer: async () => buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength),
      };
    }
    throw new Error(`Unexpected fetch URL: ${url}`);
  }));
});

// Skip all tests if sample data is not present
const describeWithData = hasSampleData ? describe : describe.skip;

describeWithData('Manifest Loader', () => {
  it('loads and parses manifest correctly', async () => {
    const manifest = await loadManifest('/sample-data/helmholtz_manifest.json');

    expect(manifest.metadata).toBe('helmholtz_metadata.json');
    expect(manifest.probes).toBe('helmholtz_probes.json');
    expect(manifest.geometry).toBe('helmholtz_geometry.bin');
    expect(manifest.snapshots).toBeInstanceOf(Array);
    expect(manifest.snapshots.length).toBeGreaterThan(0);
  });

  it('snapshot info contains required fields', async () => {
    const manifest = await loadManifest('/sample-data/helmholtz_manifest.json');
    const firstSnapshot = manifest.snapshots[0];

    expect(firstSnapshot.time).toBe(0);
    expect(firstSnapshot.shape).toEqual([60, 50, 30]);
    expect(firstSnapshot.dtype).toBe('float16');
    expect(firstSnapshot.bytes).toBe(180000);
    expect(firstSnapshot.file).toBe('helmholtz_snapshot_0000.bin');
  });
});

describeWithData('Metadata Loader', () => {
  it('loads and parses metadata correctly', async () => {
    const metadata = await loadMetadata('/sample-data/helmholtz_metadata.json');

    expect(metadata.grid.shape).toEqual([60, 50, 30]);
    expect(metadata.grid.resolution).toBe(0.002);
    expect(metadata.physics.c).toBe(343.0);
    expect(metadata.physics.rho).toBe(1.2);
  });

  it('contains simulation timing info', async () => {
    const metadata = await loadMetadata('/sample-data/helmholtz_metadata.json');

    expect(metadata.simulation.dt).toBeGreaterThan(0);
    expect(metadata.simulation.stepCount).toBeGreaterThan(0);
    expect(metadata.simulation.cflLimit).toBeGreaterThan(0);
  });

  it('contains probe definitions', async () => {
    const metadata = await loadMetadata('/sample-data/helmholtz_metadata.json');

    expect(metadata.probes).toHaveProperty('upstream');
    expect(metadata.probes).toHaveProperty('downstream');
    expect(metadata.probes).toHaveProperty('cavity');
  });
});

describeWithData('Snapshot Loader', () => {
  it('loads float16 snapshot correctly', async () => {
    const snapshotInfo: SnapshotInfo = {
      time: 0,
      shape: [60, 50, 30],
      dtype: 'float16',
      format: 'float16',
      downsample: 1,
      file: '/sample-data/helmholtz_snapshot_0000.bin',
      bytes: 180000,
    };

    const snapshot = await loadSnapshot('/sample-data/helmholtz_snapshot_0000.bin', snapshotInfo);

    expect(snapshot.time).toBe(0);
    expect(snapshot.shape).toEqual([60, 50, 30]);
    expect(snapshot.pressure).toBeInstanceOf(Float32Array);
    expect(snapshot.pressure.length).toBe(60 * 50 * 30);
  });

  it('pressure values are finite', async () => {
    const snapshotInfo: SnapshotInfo = {
      time: 0,
      shape: [60, 50, 30],
      dtype: 'float16',
      format: 'float16',
      downsample: 1,
      file: '/sample-data/helmholtz_snapshot_0000.bin',
      bytes: 180000,
    };

    const snapshot = await loadSnapshot('/sample-data/helmholtz_snapshot_0000.bin', snapshotInfo);

    // Check all values are finite (not NaN or Infinity)
    let allFinite = true;
    for (const val of snapshot.pressure) {
      if (!Number.isFinite(val)) {
        allFinite = false;
        break;
      }
    }
    expect(allFinite).toBe(true);
  });
});

describeWithData('Geometry Loader', () => {
  it('loads packed bits geometry correctly', async () => {
    const geometryInfo: GeometryInfo = {
      shape: [60, 50, 30],
      format: 'packed_bits',
      file: '/sample-data/helmholtz_geometry.bin',
      bytes: 11250,
    };

    const geometry = await loadGeometry('/sample-data/helmholtz_geometry.bin', geometryInfo);

    expect(geometry.shape).toEqual([60, 50, 30]);
    expect(geometry.mask).toBeInstanceOf(Uint8Array);
    expect(geometry.mask.length).toBe(60 * 50 * 30);
  });

  it('geometry values are 0 or 1', async () => {
    const geometryInfo: GeometryInfo = {
      shape: [60, 50, 30],
      format: 'packed_bits',
      file: '/sample-data/helmholtz_geometry.bin',
      bytes: 11250,
    };

    const geometry = await loadGeometry('/sample-data/helmholtz_geometry.bin', geometryInfo);

    let allValid = true;
    for (const val of geometry.mask) {
      if (val !== 0 && val !== 1) {
        allValid = false;
        break;
      }
    }
    expect(allValid).toBe(true);
  });

  it('has expected air/solid ratio', async () => {
    const geometryInfo: GeometryInfo = {
      shape: [60, 50, 30],
      format: 'packed_bits',
      file: '/sample-data/helmholtz_geometry.bin',
      bytes: 11250,
    };

    const geometry = await loadGeometry('/sample-data/helmholtz_geometry.bin', geometryInfo);

    let airCells = 0;
    for (const val of geometry.mask) {
      if (val === 1) airCells++;
    }

    // Sample data has ~8250 air cells out of 90000 total (60*50*30)
    expect(airCells).toBeGreaterThan(5000);
    expect(airCells).toBeLessThan(20000);
  });
});

describeWithData('Probe Data Loader', () => {
  it('loads probe data correctly', async () => {
    const probeData = await loadProbeData('/sample-data/helmholtz_probes.json');

    expect(probeData.sampleRate).toBeGreaterThan(0);
    expect(probeData.dt).toBeGreaterThan(0);
    expect(probeData.nSamples).toBeGreaterThan(0);
    expect(probeData.probes).toHaveProperty('upstream');
    expect(probeData.probes).toHaveProperty('downstream');
    expect(probeData.probes).toHaveProperty('cavity');
  });

  it('probe data is Float32Array', async () => {
    const probeData = await loadProbeData('/sample-data/helmholtz_probes.json');

    expect(probeData.probes['upstream'].data).toBeInstanceOf(Float32Array);
    expect(probeData.probes['downstream'].data).toBeInstanceOf(Float32Array);
    expect(probeData.probes['cavity'].data).toBeInstanceOf(Float32Array);
  });

  it('probe positions are valid', async () => {
    const probeData = await loadProbeData('/sample-data/helmholtz_probes.json');

    for (const probe of Object.values(probeData.probes)) {
      expect(probe.position).toHaveLength(3);
      expect(probe.position.every((p) => Number.isInteger(p))).toBe(true);
    }
  });
});

describeWithData('Probe Analysis Utilities', () => {
  it('getTimeArray creates correct length array', async () => {
    const probeData = await loadProbeData('/sample-data/helmholtz_probes.json');
    const timeArray = getTimeArray(probeData);

    expect(timeArray).toBeInstanceOf(Float32Array);
    expect(timeArray.length).toBe(probeData.nSamples);
  });

  it('getTimeArray values are monotonically increasing', async () => {
    const probeData = await loadProbeData('/sample-data/helmholtz_probes.json');
    const timeArray = getTimeArray(probeData);

    for (let i = 1; i < timeArray.length; i++) {
      expect(timeArray[i]).toBeGreaterThan(timeArray[i - 1]);
    }
  });

  it('getFrequencyResponse returns valid spectrum', async () => {
    const probeData = await loadProbeData('/sample-data/helmholtz_probes.json');
    const { frequencies, magnitude } = getFrequencyResponse(
      probeData.probes['upstream'].data,
      probeData.sampleRate
    );

    expect(frequencies).toBeInstanceOf(Float32Array);
    expect(magnitude).toBeInstanceOf(Float32Array);
    expect(frequencies.length).toBe(magnitude.length);

    // Frequencies should be non-negative
    for (const f of frequencies) {
      expect(f).toBeGreaterThanOrEqual(0);
    }

    // Magnitudes should be non-negative
    for (const m of magnitude) {
      expect(m).toBeGreaterThanOrEqual(0);
    }
  });
});

describeWithData('Float16 Conversion', () => {
  // Test the float16 to float32 conversion by checking known values
  it('handles zero correctly', async () => {
    const snapshotInfo: SnapshotInfo = {
      time: 0,
      shape: [60, 50, 30],
      dtype: 'float16',
      format: 'float16',
      downsample: 1,
      file: '/sample-data/helmholtz_snapshot_0000.bin',
      bytes: 180000,
    };

    const snapshot = await loadSnapshot('/sample-data/helmholtz_snapshot_0000.bin', snapshotInfo);

    // First snapshot at t=0 should have lots of zeros
    let zeroCount = 0;
    for (const val of snapshot.pressure) {
      if (val === 0) zeroCount++;
    }

    // Most of the domain should be zero initially
    expect(zeroCount).toBeGreaterThan(snapshot.pressure.length * 0.5);
  });
});
