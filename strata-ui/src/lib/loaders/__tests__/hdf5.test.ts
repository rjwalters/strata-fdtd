/**
 * Unit tests for HDF5 loader module.
 *
 * Tests HDF5 data conversion and validation functions.
 *
 * Note: These tests focus on the toSimulationMetadata converter function
 * and HDF5SimulationData structure validation. They test real logic without
 * heavy mocking.
 *
 * Future work: Integration tests with actual HDF5 files generated by the
 * Python FDTD solver would provide more comprehensive coverage of the
 * loadHDF5File/loadHDF5FromURL functions and h5wasm integration.
 */

import { describe, it, expect } from "vitest";
import { toSimulationMetadata, type HDF5SimulationData } from "../hdf5";

// Helper to create sample HDF5 data for conversion tests
function createSampleHDF5Data(): HDF5SimulationData {
  return {
    metadata: {
      scriptHash: "abc123def456",
      scriptContent: "# Test simulation script\nprint('hello')",
      createdAt: "2024-01-15T10:30:00Z",
      solverVersion: "1.2.3",
      backend: "native",
      numThreads: 8,
      totalRuntimeSeconds: 42.5,
    },
    grid: {
      shape: [60, 50, 30],
      resolution: 0.002,
      extent: [0.12, 0.1, 0.06],
      isUniform: true,
    },
    simulation: {
      timestep: 1e-6,
      numSteps: 100,
      cflNumber: 0.5,
      totalTime: 1e-4,
      pmlThickness: 10,
    },
    materials: new Uint8Array([0, 0, 1, 1, 0]),
    materialMap: { "0": "air", "1": "solid" },
    numSteps: 100,
    timestep: 1e-6,
    probes: {
      sampleRate: 1e6,
      dt: 1e-6,
      duration: 1e-4,
      nSamples: 100,
      probes: {
        probe_0: {
          position: [10, 20, 15],
          data: new Float32Array(100),
        },
        probe_1: {
          position: [30, 25, 20],
          data: new Float32Array(100),
        },
      },
    },
    sources: [
      {
        type: "sine",
        position: [30, 25, 15],
        frequency: 1000,
        bandwidth: 100,
        amplitude: 1.0,
      },
      {
        type: "gaussian_pulse",
        position: [40, 30, 20],
        frequency: 2000,
      },
    ],
    geometry: {
      mask: new Uint8Array(60 * 50 * 30), // Correct size for grid
      shape: [60, 50, 30],
    },
  };
}

describe("HDF5 Loader", () => {
  describe("toSimulationMetadata", () => {
    it("should convert HDF5 data to SimulationMetadata format", () => {
      const hdf5Data = createSampleHDF5Data();
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.grid.shape).toEqual([60, 50, 30]);
      expect(metadata.grid.resolution).toBe(0.002);
      expect(metadata.grid.physicalSize).toEqual([0.12, 0.1, 0.06]);
    });

    it("should set default physics constants", () => {
      const hdf5Data = createSampleHDF5Data();
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.physics.c).toBe(343);
      expect(metadata.physics.rho).toBe(1.225);
    });

    it("should map simulation parameters correctly", () => {
      const hdf5Data = createSampleHDF5Data();
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.simulation.dt).toBe(1e-6);
      expect(metadata.simulation.stepCount).toBe(100);
      expect(metadata.simulation.cflLimit).toBe(0.5);
      expect(metadata.simulation.currentTime).toBe(1e-4);
    });

    it("should map all probes with positions", () => {
      const hdf5Data = createSampleHDF5Data();
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.probes).toHaveProperty("probe_0");
      expect(metadata.probes).toHaveProperty("probe_1");
      expect(metadata.probes.probe_0.position).toEqual([10, 20, 15]);
      expect(metadata.probes.probe_1.position).toEqual([30, 25, 20]);
    });

    it("should map all sources with all properties", () => {
      const hdf5Data = createSampleHDF5Data();
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.sources).toHaveLength(2);

      // First source (complete)
      expect(metadata.sources[0].type).toBe("sine");
      expect(metadata.sources[0].position).toEqual([30, 25, 15]);
      expect(metadata.sources[0].frequency).toBe(1000);
      expect(metadata.sources[0].bandwidth).toBe(100);

      // Second source (partial - missing optional fields)
      expect(metadata.sources[1].type).toBe("gaussian_pulse");
      expect(metadata.sources[1].position).toEqual([40, 30, 20]);
      expect(metadata.sources[1].frequency).toBe(2000);
      expect(metadata.sources[1].bandwidth).toBe(0); // default
    });

    it("should include metadata in extra field", () => {
      const hdf5Data = createSampleHDF5Data();
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.extra).toBeDefined();
      expect(metadata.extra?.scriptHash).toBe("abc123def456");
      expect(metadata.extra?.createdAt).toBe("2024-01-15T10:30:00Z");
      expect(metadata.extra?.solverVersion).toBe("1.2.3");
    });

    it("should handle empty probes", () => {
      const hdf5Data = createSampleHDF5Data();
      hdf5Data.probes.probes = {};
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.probes).toEqual({});
    });

    it("should handle empty sources", () => {
      const hdf5Data = createSampleHDF5Data();
      hdf5Data.sources = [];
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.sources).toEqual([]);
    });

    it("should handle sources with missing optional properties", () => {
      const hdf5Data = createSampleHDF5Data();
      hdf5Data.sources = [
        {
          type: "impulse",
          position: [5, 5, 5],
        },
      ];
      const metadata = toSimulationMetadata(hdf5Data);

      expect(metadata.sources).toHaveLength(1);
      expect(metadata.sources[0].frequency).toBe(0);
      expect(metadata.sources[0].bandwidth).toBe(0);
    });
  });

  describe("HDF5SimulationData structure", () => {
    it("should have all required fields", () => {
      const data = createSampleHDF5Data();

      expect(data).toHaveProperty("metadata");
      expect(data).toHaveProperty("grid");
      expect(data).toHaveProperty("simulation");
      expect(data).toHaveProperty("materials");
      expect(data).toHaveProperty("materialMap");
      expect(data).toHaveProperty("numSteps");
      expect(data).toHaveProperty("timestep");
      expect(data).toHaveProperty("probes");
      expect(data).toHaveProperty("sources");
      expect(data).toHaveProperty("geometry");
    });

    it("should have correct grid structure", () => {
      const data = createSampleHDF5Data();

      expect(data.grid.shape).toHaveLength(3);
      expect(data.grid.shape.every((n) => typeof n === "number")).toBe(true);
      expect(typeof data.grid.resolution).toBe("number");
      expect(data.grid.extent).toHaveLength(3);
      expect(typeof data.grid.isUniform).toBe("boolean");
    });

    it("should have correct simulation parameters", () => {
      const data = createSampleHDF5Data();

      expect(typeof data.simulation.timestep).toBe("number");
      expect(typeof data.simulation.numSteps).toBe("number");
      expect(typeof data.simulation.cflNumber).toBe("number");
      expect(typeof data.simulation.totalTime).toBe("number");
    });

    it("should have probe data with positions and time series", () => {
      const data = createSampleHDF5Data();

      for (const [name, probe] of Object.entries(data.probes.probes)) {
        expect(name).toBeTruthy();
        expect(probe.position).toHaveLength(3);
        expect(probe.data).toBeInstanceOf(Float32Array);
      }
    });

    it("should have source definitions with required fields", () => {
      const data = createSampleHDF5Data();

      for (const source of data.sources) {
        expect(typeof source.type).toBe("string");
        expect(source.position).toHaveLength(3);
      }
    });

    it("should allow null materials and geometry", () => {
      const data = createSampleHDF5Data();
      data.materials = null;
      data.geometry = null;

      expect(data.materials).toBeNull();
      expect(data.geometry).toBeNull();
    });
  });

  describe("Data validation", () => {
    it("should have consistent numSteps", () => {
      const data = createSampleHDF5Data();

      expect(data.numSteps).toBe(data.simulation.numSteps);
    });

    it("should have consistent timestep", () => {
      const data = createSampleHDF5Data();

      expect(data.timestep).toBe(data.simulation.timestep);
    });

    it("should have probe sample rate matching timestep", () => {
      const data = createSampleHDF5Data();

      const expectedSampleRate = 1 / data.timestep;
      expect(data.probes.sampleRate).toBeCloseTo(expectedSampleRate);
    });

    it("should have probe dt matching simulation timestep", () => {
      const data = createSampleHDF5Data();

      expect(data.probes.dt).toBe(data.simulation.timestep);
    });

    it("should have probe duration consistent with samples", () => {
      const data = createSampleHDF5Data();

      const expectedDuration = data.probes.nSamples * data.probes.dt;
      expect(data.probes.duration).toBeCloseTo(expectedDuration);
    });

    it("should have geometry mask matching grid size", () => {
      const data = createSampleHDF5Data();

      if (data.geometry) {
        const [nx, ny, nz] = data.grid.shape;
        const expectedSize = nx * ny * nz;
        expect(data.geometry.mask.length).toBe(expectedSize);
        expect(data.geometry.shape).toEqual(data.grid.shape);
      }
    });

    it("should have materials array matching grid size", () => {
      const data = createSampleHDF5Data();

      if (data.materials) {
        // Grid shape is available but not needed for this test
        // const [nx, ny, nz] = data.grid.shape;
        // Materials might be smaller (just metadata), so this is informational
        expect(data.materials).toBeInstanceOf(Uint8Array);
      }
    });
  });

  describe("Edge cases", () => {
    it("should handle single probe", () => {
      const data = createSampleHDF5Data();
      data.probes.probes = {
        single_probe: {
          position: [0, 0, 0],
          data: new Float32Array(10),
        },
      };

      const metadata = toSimulationMetadata(data);
      expect(Object.keys(metadata.probes)).toHaveLength(1);
      expect(metadata.probes.single_probe).toBeDefined();
    });

    it("should handle many probes", () => {
      const data = createSampleHDF5Data();
      data.probes.probes = {};

      for (let i = 0; i < 100; i++) {
        data.probes.probes[`probe_${i}`] = {
          position: [i, i, i],
          data: new Float32Array(100),
        };
      }

      const metadata = toSimulationMetadata(data);
      expect(Object.keys(metadata.probes)).toHaveLength(100);
    });

    it("should handle minimal valid data", () => {
      const minimalData: HDF5SimulationData = {
        metadata: {
          scriptHash: "",
          scriptContent: "",
          createdAt: new Date().toISOString(),
          solverVersion: "unknown",
        },
        grid: {
          shape: [10, 10, 10],
          resolution: 0.01,
          extent: [0.1, 0.1, 0.1],
          isUniform: true,
        },
        simulation: {
          timestep: 1e-5,
          numSteps: 10,
          cflNumber: 0.5,
          totalTime: 1e-4,
        },
        materials: null,
        materialMap: {},
        numSteps: 10,
        timestep: 1e-5,
        probes: {
          sampleRate: 1e5,
          dt: 1e-5,
          duration: 1e-4,
          nSamples: 10,
          probes: {},
        },
        sources: [],
        geometry: null,
      };

      const metadata = toSimulationMetadata(minimalData);
      expect(metadata).toBeDefined();
      expect(metadata.grid.shape).toEqual([10, 10, 10]);
    });
  });
});
